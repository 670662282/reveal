<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );



    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-markdown data-separator="---" data-separator-vertical="@@@">
            <script type="text/template">
                # QA团队自动化测试实践之路

                @Create By Xiao Ao
                ---
                ## 自动化测试的认知误区
                自动化测试不是为了发现更多的缺陷
                @@@
                自动化测试的意义更在守住软件质量的底线，确保工作正常软件在新功能引入的不会带来质量回退

                ---
                ## 认识自动化的不足
                1. 自动化测试不能代替手工测试  <!-- .element: class="fragment" data-fragment-index="1" -->
                2. 测试用例脆弱、不够智能，无法应对被测系统的变化 <!-- .element: class="fragment" data-fragment-index="2" -->
                3. 测试用例开发工作量远大于单次手工测试量 <!-- .element: class="fragment" data-fragment-index="3" -->
                4. 在实施自动化测试初期 用例开发效率低 <!-- .element: class="fragment" data-fragment-index="4" -->

                ---
                ## 自动化测试用例开发的基本原则
                - DAMP原则（通过描述性和有意义的短语来增加可读性）
                - DRY原则（避免冗余）
                @@@
                例子：
                 <pre><code data-trim class="hljs" data-line-numbers="1,2">
                     def test_force_cache_policy_not_match_source_ip:
                         domain_name, vip, site_id, domain_port_id = get_domain_by_forced_cache(
                            match_url=url,
                            src_ip_list=source_ip
                            extension_list=extension
                         )
                         open_browser(f"http://{vip}{url}")
                         f5
                         should_be_equal(get_response_headers()['Cache-stat'], 'MISS')
                 </code></pre>
                ---
                ## 自动化测试 编写基本流程

                1. <strong> 准备测试数据</strong>
                2. 请求被测系统服务
                3. <strong>验证被测系统服务是否符合预期</strong>
                4. 清理测试数据

                @@@
                ### 准备测试数据
                创建测试数据的方式
                - 实时创建方法
                - 事先创建方法

                @@@
                实时创建方法

                优点：
                - 不依赖测试用例以外的任何数据，保证了准确性和可控性，避免了脏数据的可能性

                缺点：
                - 实时创建数据相对比较耗时
                - 如果测试数据存在比较复杂的依赖性， 创建一个数据前，需要创建它的前置数据，复杂度和创建数据时间都会上升

                @@@
                事先创建方法

                优点：
                - 既拿既用
                缺点：
                - 脏数据
                - 事先创建的东西，界面上被别人动了导致数据变化，或者自动化运行过程中改变了数据的状态

                @@@
                事先创建方法和实时创建方法的使用场景
                这个应该由被测业务来决定
                - 相关测试操作不改变测试数据状态， 事先创建 <!-- .element: class="fragment" data-fragment-index="1" -->
                - 相关测试操作会改变测试数据状态， 实时创建     <!-- .element: class="fragment" data-fragment-index="2" -->

                <aside class="notes">
                你要测试site某个功能，那么customer 数据如何你并不关心，测试site也不会改变customer的数据状态，那么这个customer 就可以事先创建，用完后无需删除
                你要测试customer 某个功能， 你对customer数据有要求，而且测试customer过程中可能改变了customer 状态，这个custom应该实时创建且用后删除
                </aside>

                ---
                ## 自动化测试的演进之路
                @@@
                ###  api自动化测试1.0
                ### 一个简单的测试用例的写法
                <pre><code data-trim class="hljs" data-line-numbers="6,8-12">
                # test_ap_site.py
                class ApiUnitTest(unittest.TestCase):

                    @classmethod
                    def setUpClass(cls):
                        cls.api_client = HttpClient()

                    def test_create_site(self):
                        url = "http://xxx.com/create_site"
                        resp = self.api_client.post(url, data={"site_name": 'auto_create_site'})
                        self.assertEqual(resp.json()['code'],  0)
                        self.assertEqual(resp.json()['result']['site_name'], 'auto_create_site')

                    def test_create_chinese_name_site(self):
                        url = "http://xxx.com/create_site"
                        resp = self.api_client.post(url, data={"site_name": '中文site'})
                        self.assertEqual(resp.json()['code'],  0)
                        self.assertEqual(resp.json()['result']['site_name'], '中文site')
                </code></pre>

                ---
                ### api自动化测试2.0
                ### 自动化生成可复用的api代码
                支持以下格式生成api sdk client代码
                - [swagger](https://swagger.io/specification/v2/)  描述REST API的格式的一组规范
                - [Har(HTTP Archive)](http://www.softwareishard.com/blog/har-12-spec/) 一个用来储存HTTP请求/响应信息的格式的"JSON文件"
                目前统计 一共生成了1w多行代码（去除空格和注释）
                @@@
                <pre><code data-trim class="hljs">
                    # swagger docs生成的一个api
                def get_op_site_list_op(customer_id: str,
                        access_token: str,
                        client_=None,
                        **kwargs):
                """Retrieves Origin Protection site list by Customer ID.
                :param client_  requests session client
                :param customer_id ('Unique identifier of a customer. Can be obtained by invoking [this '
             'API](#retrieves-a-list-of-customers-with-pagination).')
                :type: string, required:True
                    省略部分接口文档
                :return: resp -> response object
                """

                    name_ = kwargs.pop('name_', 'get_op_site_list_op')
                    url_ = f'/spe/customer/{customer_id}/op/sites'
                    resp = client_.get(url_,
                                       params={'access_token': access_token},
                                       name=name_,
                                       **kwargs)
                    return ResponseObj(resp)
                </code></pre>
                @@@
                2.0的测试用例写法如下
                <pre><code data-trim class="hljs" data-line-numbers="14,18,4-8">
                api_client = HttpClient()

                class ApiUnitTest(unittest.TestCase):

                    def test_create_site(self):
                        resp = create_site('normal_site', api_client)
                        self.assertEqual(resp.json()['code'],  0)
                        self.assertEqual(resp.json()['result']['site_name'], 'normal_site')

                    def test_create_chinese_name_site(self):
                        resp = create_site('中文site',  api_client)
                        self.assertEqual(resp.json()['code'],  0)
                        self.assertEqual(resp.json()['result']['site_name'], '中文site')
                </code></pre>
                ---
                ### api自动化测试3.0
                ### 进一步增加test case编写的简便性和易读性
                - 封装断言assert
                - 增加response数据抽取器
                - 链式编写（利用编辑器的提示达到易用性）
                @@@
                <pre><code data-trim class="hljs" data-line-numbers="5-6,10-11">
                api_client = HttpClient()
                class ApiUnitTest(unittest.TestCase):
                    def test_create_site(self):
                        create_site('normal_site', api_client
                        ).assert_code(
                        ).assert_resp_json("result.site_name", 'normal_site')

                    def test_create_chinese_name_site(self):
                        create_site('中文site', api_client
                        ).assert_code(
                        ).assert_resp_json("result.site_name", '中文site')
                </code></pre>

                ---
                ### api自动化测试4.0
                ### 测试框架化
                - 自定义request库
                - 多环境配置切换功能
                - 接口代码生成功能
                - 自动监测 response 结构以及字段值的变化
                - response json 数据抽取器
                @@@
                ### 测试框架化
                - response json schema验证
                - cli命令行调用测试执行
                - testcase tag 标签化
                - 测试报告
                - 数据驱动功能（测试数据变量化）
                ---
                ### api自动化测试5.0
                ### spe接口和specp接口用例复用
                test case 用例代码减少百分之45%
                ---
                ### 自动化测试6.0
                ### 测试执行环境docker化
                - 通过组合多个docker-compose 配置文件达到切换测试执行环境
                - 拆分test case到不同docker中并行运行
                <pre><code data-trim class="hljs">
                    docker-compose -f docker-compose.yml -f docker-compose.qlo1-cdd.yml    up -d
                    docker-compose -f docker-compose.yml -f docker-compose.staging-cdd.yml up -d
                </code></pre>

            </script>
        </section>

<!--        <section data-background-iframe="https://jsonschema.net/" data-background-interactive>-->
<!--        </section>-->

        <section>
            <section data-markdown="">
                ## 自动化测试基础构架
            </section>
            <section data-markdown>
                ![image](images/自动化测试基础构架.png)
            </section>
        </section>

        <section>
            <p class="fragment">
                总结
            <aside class="notes">
                这里是注释。
            </aside>
            </p>

        </section>
    </div>
</div>

<script src="js/reveal.js"></script>

<script>
            // More info about config & dependencies:
            // - https://github.com/hakimel/reveal.js#configuration
            // - https://github.com/hakimel/reveal.js#dependencies
            Reveal.initialize({
                <!--width: "100%",-->
                <!--height: "100%",-->
                <!--margin: 0,-->
                <!--minScale: 1,-->
                <!--maxScale: 1,-->
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true }
                ],

            // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
            });




</script>
</body>
</html>